<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Redactor</title>
    <!-- CodeMirror CSS -->
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/codemirror.min.css"
    />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/theme/material-darker.min.css"
    />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/theme/eclipse.min.css"
    />

    <script src="https://cdn.tailwindcss.com"></script>
    <script>
      // Set theme on initial load to prevent FOUC (Flash of Unstyled Content)
      const savedSettings =
        JSON.parse(localStorage.getItem("redactorSettings")) || {};
      if (
        savedSettings.ui?.useDarkTheme === true ||
        (savedSettings.ui?.useDarkTheme === undefined &&
          window.matchMedia("(prefers-color-scheme: dark)").matches)
      ) {
        document.documentElement.classList.add("dark");
      } else {
        document.documentElement.classList.remove("dark");
      }
    </script>
    <style>
      /* Custom scrollbar styles */
      ::-webkit-scrollbar {
        width: 8px;
        height: 8px;
      }
      /* Light theme scrollbar */
      ::-webkit-scrollbar-track {
        background: #e5e7eb;
      }
      ::-webkit-scrollbar-thumb {
        background: #9ca3af;
        border-radius: 4px;
      }
      ::-webkit-scrollbar-thumb:hover {
        background: #6b7280;
      }
      /* Dark theme scrollbar */
      .dark ::-webkit-scrollbar-track {
        background: #1f2937;
      }
      .dark ::-webkit-scrollbar-thumb {
        background: #4b5563;
      }
      .dark ::-webkit-scrollbar-thumb:hover {
        background: #6b7280;
      }

      /* Hide scrollbar for the tabs container */
      #tabs-container::-webkit-scrollbar {
        display: none;
      }
      /* Simple splitter styling */
      .splitter {
        flex: 0 0 5px;
        cursor: col-resize;
        z-index: 10;
      }
      /* Prevents text selection during UI interactions */
      .select-none {
        user-select: none;
      }
      /* Custom checkbox style */
      input[type="checkbox"] {
        appearance: none;
        width: 1.25rem;
        height: 1.25rem;
        border-radius: 0.25rem;
        display: grid;
        place-content: center;
        cursor: pointer;
      }
      input[type="checkbox"]::before {
        content: "";
        width: 0.75rem;
        height: 0.75rem;
        transform: scale(0);
        transition: 120ms transform ease-in-out;
        box-shadow: inset 1em 1em #3b82f6;
        transform-origin: bottom left;
        clip-path: polygon(14% 44%, 0 65%, 50% 100%, 100% 16%, 80% 0%, 43% 62%);
      }
      input[type="checkbox"]:checked::before {
        transform: scale(1);
      }
      /* CodeMirror styles */
      .CodeMirror {
        height: 100%;
        font-size: 14px;
        border-radius: 0.375rem;
      }
      .CodeMirror-placeholder {
        color: #9ca3af !important;
      }
      .dark .CodeMirror-placeholder {
        color: #6b7280 !important;
      }
    </style>
  </head>
  <body
    class="bg-white dark:bg-gray-800 text-gray-900 dark:text-gray-200 font-sans h-screen flex flex-col transition-colors duration-300 pb-8"
  >
    <!-- Tab Bar -->
    <div
      id="tab-bar"
      class="flex items-center bg-gray-100 dark:bg-gray-900 px-2 select-none border-b border-gray-300 dark:border-gray-700"
    >
      <button
        id="scroll-left-button"
        class="hidden p-1 text-gray-500 dark:text-gray-400 hover:bg-gray-200 dark:hover:bg-gray-700 rounded-md transition-colors duration-150"
      >
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width="18"
          height="18"
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          stroke-width="2"
          stroke-linecap="round"
          stroke-linejoin="round"
        >
          <polyline points="15 18 9 12 15 6"></polyline>
        </svg>
      </button>
      <div id="tabs-wrapper" class="flex-grow overflow-hidden">
        <div
          id="tabs-container"
          class="flex items-end overflow-x-auto scroll-smooth"
        >
          <!-- Tabs and the add button will be dynamically inserted here -->
        </div>
      </div>
      <button
        id="scroll-right-button"
        class="hidden p-1 text-gray-500 dark:text-gray-400 hover:bg-gray-200 dark:hover:bg-gray-700 rounded-md transition-colors duration-150"
      >
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width="18"
          height="18"
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          stroke-width="2"
          stroke-linecap="round"
          stroke-linejoin="round"
        >
          <polyline points="9 18 15 12 9 6"></polyline>
        </svg>
      </button>
      <button
        id="settings-button"
        title="Redaction Settings"
        class="ml-4 p-1 text-gray-500 dark:text-gray-400 hover:bg-gray-200 dark:hover:bg-gray-700 rounded-md transition-colors duration-150"
      >
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width="18"
          height="18"
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          stroke-width="2"
          stroke-linecap="round"
          stroke-linejoin="round"
        >
          <circle cx="12" cy="12" r="3"></circle>
          <path
            d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"
          ></path>
        </svg>
      </button>
    </div>

    <div id="container" class="flex-grow flex w-full overflow-hidden px-4 pt-4">
      <!-- Input Panel -->
      <div id="left-panel" class="flex flex-col w-1/2 h-full p-2">
        <div class="flex justify-between items-center mb-2">
          <label class="text-lg font-semibold">Original Data</label>
          <div class="flex items-center space-x-2">
            <span
              id="detected-format"
              class="text-sm bg-gray-200 dark:bg-gray-700 px-2 py-1 rounded"
            ></span>
          </div>
        </div>
        <div id="input-editor" class="flex-grow overflow-hidden"></div>
      </div>

      <div
        id="splitter"
        class="splitter bg-gray-300 dark:bg-gray-600 h-full"
      ></div>

      <!-- Output Panel -->
      <div id="right-panel" class="flex flex-col w-1/2 h-full p-2">
        <div class="flex items-center justify-between mb-2">
          <label class="text-lg font-semibold">Redacted Data</label>
          <button
            id="copy-button"
            title="Copy to clipboard"
            class="text-gray-500 dark:text-gray-400 hover:text-gray-900 dark:hover:text-white transition-colors duration-150 p-1 rounded-md"
          >
            <svg
              xmlns="http://www.w3.org/2000/svg"
              width="18"
              height="18"
              viewBox="0 0 24 24"
              fill="none"
              stroke="currentColor"
              stroke-width="2"
              stroke-linecap="round"
              stroke-linejoin="round"
            >
              <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
              <path
                d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"
              ></path>
            </svg>
          </button>
        </div>
        <div id="output-editor" class="flex-grow overflow-hidden"></div>
      </div>
    </div>

    <div class="flex justify-end px-6 py-4">
      <button
        id="redact-button"
        class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-4 rounded-lg text-lg transition duration-200"
      >
        Redact
      </button>
    </div>

    <!-- Error Toast -->
    <div
      id="error-toast"
      class="hidden fixed bottom-5 right-5 bg-red-600 text-white py-2 px-4 rounded-lg shadow-lg"
    >
      <span id="error-message"></span>
    </div>

    <!-- Powered by Label -->
    <div
      class="fixed bottom-1 right-2 text-xs text-gray-500 dark:text-gray-400"
    >
      Found any bugs? Please submit an issue to
      <a
        href="https://github.com"
        target="_blank"
        class="underline hover:text-blue-500 dark:hover:text-blue-400"
        >GitHub</a
      >. Powered by Refactor Security
    </div>

    <!-- Settings Modal -->
    <div
      id="settings-modal"
      class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50"
    >
      <div
        class="bg-white dark:bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-lg border border-gray-300 dark:border-gray-700"
      >
        <div class="flex justify-between items-center mb-4">
          <h2 class="text-xl font-bold">Settings</h2>
          <button
            id="close-settings-button"
            class="text-gray-500 dark:text-gray-400 hover:text-gray-900 dark:hover:text-white text-3xl font-light"
          >
            &times;
          </button>
        </div>

        <div class="space-y-6">
          <!-- Redacting Settings -->
          <div>
            <h3
              class="text-lg font-semibold mb-3 border-b border-gray-300 dark:border-gray-600 pb-2"
            >
              Redacting Settings
            </h3>
            <div class="space-y-4 pl-2">
              <label class="flex items-center cursor-pointer">
                <input
                  type="checkbox"
                  id="setting-redact-url-path"
                  class="bg-gray-300 dark:bg-gray-600"
                />
                <span class="ml-3">Redact URL path</span>
              </label>
              <label class="flex items-center cursor-pointer">
                <input
                  type="checkbox"
                  id="setting-redact-query-string"
                  class="bg-gray-300 dark:bg-gray-600"
                  checked
                />
                <span class="ml-3">Redact query string values</span>
              </label>
              <label class="flex items-center cursor-pointer">
                <input
                  type="checkbox"
                  id="setting-redact-param-names"
                  class="bg-gray-300 dark:bg-gray-600"
                />
                <span class="ml-3">Redact parameter names</span>
              </label>
              <label class="flex items-center cursor-pointer">
                <input
                  type="checkbox"
                  id="setting-redact-cookies"
                  class="bg-gray-300 dark:bg-gray-600"
                  checked
                />
                <span class="ml-3"
                  >Redact cookie/auth values (preserves names)</span
                >
              </label>
              <label class="flex items-center cursor-pointer">
                <input
                  type="checkbox"
                  id="setting-redact-csrf"
                  class="bg-gray-300 dark:bg-gray-600"
                  checked
                />
                <span class="ml-3">Redact CSRF tokens (in headers & body)</span>
              </label>
              <div>
                <label
                  for="setting-ignored-words"
                  class="block mb-2 text-sm font-medium"
                  >Ignored Words (comma-separated)</label
                >
                <textarea
                  id="setting-ignored-words"
                  rows="3"
                  class="w-full p-2 bg-gray-200 dark:bg-gray-700 border border-gray-300 dark:border-gray-600 rounded-md focus:ring-2 focus:ring-blue-500 focus:outline-none text-sm"
                  placeholder="e.g. Bearer, token, secret"
                ></textarea>
              </div>
            </div>
          </div>

          <!-- UI Settings -->
          <div>
            <h3
              class="text-lg font-semibold mb-3 border-b border-gray-300 dark:border-gray-600 pb-2"
            >
              UI Settings
            </h3>
            <div class="space-y-3 pl-2">
              <label class="flex items-center cursor-pointer">
                <input
                  type="checkbox"
                  id="setting-dark-theme"
                  class="bg-gray-300 dark:bg-gray-600"
                />
                <span class="ml-3">Use Dark Theme</span>
              </label>
              <label class="flex items-center cursor-pointer">
                <input
                  type="checkbox"
                  id="setting-syntax-highlight"
                  class="bg-gray-300 dark:bg-gray-600"
                  checked
                />
                <span class="ml-3">Enable Syntax Highlighting</span>
              </label>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- CodeMirror Scripts -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/codemirror.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/js-yaml/4.1.0/js-yaml.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/javascript/javascript.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/xml/xml.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/http/http.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/yaml/yaml.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/addon/display/placeholder.min.js"></script>

    <script>
      document.addEventListener("DOMContentLoaded", () => {
        const redactButton = document.getElementById("redact-button");
        const errorToast = document.getElementById("error-toast");
        const errorMessageEl = document.getElementById("error-message");
        const detectedFormatLabel = document.getElementById("detected-format");
        const tabsContainer = document.getElementById("tabs-container");
        const scrollLeftButton = document.getElementById("scroll-left-button");
        const scrollRightButton = document.getElementById(
          "scroll-right-button"
        );
        const copyButton = document.getElementById("copy-button");

        // Settings Modal Elements
        const settingsButton = document.getElementById("settings-button");
        const settingsModal = document.getElementById("settings-modal");
        const closeSettingsButton = document.getElementById(
          "close-settings-button"
        );
        const settingRedactUrlPath = document.getElementById(
          "setting-redact-url-path"
        );
        const settingRedactQueryString = document.getElementById(
          "setting-redact-query-string"
        );
        const settingRedactParamNames = document.getElementById(
          "setting-redact-param-names"
        );
        const settingRedactCookies = document.getElementById(
          "setting-redact-cookies"
        );
        const settingRedactCsrf = document.getElementById(
          "setting-redact-csrf"
        );
        const settingIgnoredWords = document.getElementById(
          "setting-ignored-words"
        );
        const settingDarkTheme = document.getElementById("setting-dark-theme");
        const settingSyntaxHighlight = document.getElementById(
          "setting-syntax-highlight"
        );

        // --- CodeMirror Editors ---
        const createEditor = (el, options) =>
          CodeMirror(el, {
            lineNumbers: true,
            lineWrapping: true,
            ...options,
          });

        const inputEditor = createEditor(
          document.getElementById("input-editor"),
          {
            theme: document.documentElement.classList.contains("dark")
              ? "material-darker"
              : "eclipse",
            placeholder:
              "Paste JSON, XML, YAML, Form URL-Encoded, HTTP, or plain text data below...",
          }
        );
        const outputEditor = createEditor(
          document.getElementById("output-editor"),
          {
            theme: document.documentElement.classList.contains("dark")
              ? "material-darker"
              : "eclipse",
            readOnly: true,
          }
        );

        // --- State Management ---
        let tabsState = [];
        let activeTabId = null;
        let tabCounter = 0;
        let settings = {};
        let syntaxUpdateTimer;

        const defaultSettings = {
          redaction: {
            redactUrlPath: false,
            redactQueryString: true,
            redactParamNames: false,
            redactCookies: true,
            redactCsrf: true,
            ignoredWords: [],
          },
          ui: {
            useDarkTheme: window.matchMedia("(prefers-color-scheme: dark)")
              .matches,
            syntaxHighlight: true,
          },
        };

        function saveSettings() {
          localStorage.setItem("redactorSettings", JSON.stringify(settings));
        }

        function loadSettings() {
          const saved = JSON.parse(localStorage.getItem("redactorSettings"));
          const savedRedaction = saved?.redaction || {};
          if (!Array.isArray(savedRedaction.ignoredWords)) {
            savedRedaction.ignoredWords = [];
          }
          settings = {
            redaction: { ...defaultSettings.redaction, ...savedRedaction },
            ui: { ...defaultSettings.ui, ...saved?.ui },
          };
          settingRedactUrlPath.checked = settings.redaction.redactUrlPath;
          settingRedactQueryString.checked =
            settings.redaction.redactQueryString;
          settingRedactParamNames.checked = settings.redaction.redactParamNames;
          settingRedactCookies.checked = settings.redaction.redactCookies;
          settingRedactCsrf.checked = settings.redaction.redactCsrf;
          settingIgnoredWords.value =
            settings.redaction.ignoredWords.join(", ");
          settingDarkTheme.checked = settings.ui.useDarkTheme;
          settingSyntaxHighlight.checked = settings.ui.syntaxHighlight;
        }

        // --- Tab Management ---
        function createNewTab() {
          tabCounter++;
          const newTab = {
            id: Date.now(),
            name: `Untitled ${tabCounter}`,
            originalName: `Untitled ${tabCounter}`,
            input: "",
            output: "",
            format: "",
          };
          tabsState.push(newTab);
          return newTab;
        }

        function switchTab(tabId) {
          if (activeTabId === tabId) return;
          activeTabId = tabId;
          render();
        }

        function closeTab(tabId) {
          const tabIndex = tabsState.findIndex((t) => t.id === tabId);
          if (tabIndex === -1) return;
          tabsState.splice(tabIndex, 1);
          if (tabsState.length === 0) {
            const newTab = createNewTab();
            activeTabId = newTab.id;
          } else if (activeTabId === tabId) {
            activeTabId = tabsState[Math.max(0, tabIndex - 1)].id;
          }
          render();
        }

        function render() {
          renderTabs();
          renderContent();
        }

        function renderTabs() {
          tabsContainer.innerHTML = "";
          tabsState.forEach((tab) => {
            const isActive = tab.id === activeTabId;
            const tabEl = document.createElement("div");
            tabEl.dataset.tabId = tab.id;
            tabEl.className = `flex-shrink-0 flex items-center cursor-pointer border-r border-t border-gray-300 dark:border-gray-700 p-2 rounded-t-md mt-2 ${
              isActive
                ? "bg-white dark:bg-gray-800 text-gray-900 dark:text-white"
                : "bg-gray-200 dark:bg-gray-700 text-gray-600 dark:text-gray-400 hover:bg-gray-300 dark:hover:bg-gray-600"
            }`;
            const titleEl = document.createElement("span");
            titleEl.textContent = tab.name;
            titleEl.className = "px-2";
            const closeBtn = document.createElement("button");
            closeBtn.textContent = "Ã—";
            closeBtn.className =
              "ml-2 w-5 h-5 flex items-center justify-center rounded-full hover:bg-red-500 hover:text-white";
            tabEl.appendChild(titleEl);
            tabEl.appendChild(closeBtn);
            tabsContainer.appendChild(tabEl);
          });
          const addButtonEl = document.createElement("button");
          addButtonEl.id = "add-tab-button";
          addButtonEl.className =
            "flex-shrink-0 ml-1 mt-2 px-3 py-2 text-xl text-gray-500 dark:text-gray-400 hover:bg-gray-200 dark:hover:bg-gray-700 rounded-t-md transition-colors duration-150";
          addButtonEl.textContent = "+";
          tabsContainer.appendChild(addButtonEl);
          setTimeout(checkTabOverflow, 0);
        }

        function getCodeMirrorMode(format) {
          if (!settings.ui.syntaxHighlight) return "text/plain";
          if (format === "JSON") return { name: "javascript", json: true };
          if (format === "XML") return "xml";
          if (format === "YAML") return "yaml";
          if (format.startsWith("HTTP")) return "http";
          return "text/plain";
        }

        function renderContent() {
          const activeTab = tabsState.find((t) => t.id === activeTabId);
          if (!activeTab) return;

          if (inputEditor.getValue() !== activeTab.input) {
            inputEditor.setValue(activeTab.input);
          }
          if (outputEditor.getValue() !== activeTab.output) {
            outputEditor.setValue(activeTab.output);
          }

          const mode = getCodeMirrorMode(activeTab.format);
          const currentMode = inputEditor.getOption("mode");

          const modesAreEqual =
            JSON.stringify(currentMode) === JSON.stringify(mode);

          if (!modesAreEqual) {
            inputEditor.setOption("mode", mode);
            outputEditor.setOption("mode", mode);
          }
          inputEditor.setOption("lineNumbers", settings.ui.syntaxHighlight);
          outputEditor.setOption("lineNumbers", settings.ui.syntaxHighlight);

          detectedFormatLabel.textContent = activeTab.format;
          setTimeout(() => {
            inputEditor.refresh();
            outputEditor.refresh();
          }, 1);
        }

        function checkTabOverflow() {
          const hasOverflow =
            tabsContainer.scrollWidth > tabsContainer.clientWidth;
          scrollLeftButton.classList.toggle("hidden", !hasOverflow);
          scrollRightButton.classList.toggle("hidden", !hasOverflow);
          if (hasOverflow) updateScrollButtonStates();
        }

        function updateScrollButtonStates() {
          const atStart = tabsContainer.scrollLeft < 1;
          const atEnd =
            tabsContainer.scrollLeft + tabsContainer.clientWidth >=
            tabsContainer.scrollWidth - 1;
          scrollLeftButton.disabled = atStart;
          scrollRightButton.disabled = atEnd;
          scrollLeftButton.classList.toggle("opacity-50", atStart);
          scrollRightButton.classList.toggle("opacity-50", atEnd);
        }

        // --- Redaction Engine ---
        class RedactionEngine {
          constructor(settings = {}) {
            this.settings = { ...settings };
            this.floatPlaceholderPrefix = "__REDACTED_FLOAT_PLACEHOLDER__:";
            this.wordMap = this.constructor.buildWordMap();
            this.ignoredWordsSet = new Set(
              (this.settings.ignoredWords || []).map((w) => w.toLowerCase())
            );
          }

          static buildWordMap() {
            const map = {};
            for (const word of this.commonWords) {
              const length = word.length;
              if (!map[length]) map[length] = [];
              map[length].push(word);
            }
            return map;
          }

          redactPrimitive(valueStr) {
            const trimmed = valueStr.trim();
            if (trimmed === "true" || trimmed === "false")
              return Math.random() < 0.5;

            const uuidRegex =
              /^[a-f\d]{8}-[a-f\d]{4}-[1-5][a-f\d]{3}-[89ab][a-f\d]{3}-[a-f\d]{12}$/i;
            if (uuidRegex.test(trimmed)) {
              return crypto.randomUUID();
            }

            const isoDateRegex =
              /^\d{4}-\d{2}-\d{2}(T\d{2}:\d{2}:\d{2}(\.\d+)?Z?)?$/;
            const commonDateRegex = /^\d{2}[-\/.]\d{2}[-\/.]\d{4}$/;

            if (isoDateRegex.test(trimmed) || commonDateRegex.test(trimmed)) {
              return this.generateRandomDate(trimmed);
            }

            if (
              !isNaN(trimmed) &&
              trimmed !== "" &&
              !isNaN(parseFloat(trimmed))
            )
              return this.redactNumber(trimmed);
            return this.redactString(valueStr);
          }

          generateRandomDate(originalDate) {
            const randomYear = Math.floor(Math.random() * 60) + 1980; // Year between 1980-2039
            const randomMonth = Math.floor(Math.random() * 12); // 0-11
            const daysInMonth = new Date(
              randomYear,
              randomMonth + 1,
              0
            ).getDate();
            const randomDay = Math.floor(Math.random() * daysInMonth) + 1;
            const date = new Date(Date.UTC(randomYear, randomMonth, randomDay));

            const pad = (n) => String(n).padStart(2, "0");

            if (originalDate.includes("T")) {
              const randomHour = Math.floor(Math.random() * 24);
              const randomMinute = Math.floor(Math.random() * 60);
              const randomSecond = Math.floor(Math.random() * 60);
              date.setUTCHours(randomHour, randomMinute, randomSecond);
              let isoString = date.toISOString();
              if (!originalDate.endsWith("Z")) {
                isoString = isoString.slice(0, -1);
              }
              return isoString;
            } else if (/^\d{4}/.test(originalDate)) {
              const separator = originalDate.charAt(4);
              return `${date.getUTCFullYear()}${separator}${pad(
                date.getUTCMonth() + 1
              )}${separator}${pad(date.getUTCDate())}`;
            } else {
              const separator = originalDate.charAt(2);
              return `${pad(date.getUTCDate())}${separator}${pad(
                date.getUTCMonth() + 1
              )}${separator}${date.getUTCFullYear()}`;
            }
          }

          redactNumber(numStr) {
            const isFloat = String(numStr).includes(".");
            let redactedStr = "";
            const digits = "0123456789";
            for (const char of String(numStr)) {
              if (digits.includes(char)) {
                redactedStr +=
                  digits[Math.floor(Math.random() * digits.length)];
              } else {
                redactedStr += char;
              }
            }
            if (isFloat) {
              const originalDecimalPlaces = (String(numStr).split(".")[1] || "")
                .length;
              let [intPart, decPart = ""] = redactedStr.split(".");
              while (decPart.length < originalDecimalPlaces) decPart += "0";
              redactedStr =
                intPart + "." + decPart.slice(0, originalDecimalPlaces);
              return this.floatPlaceholderPrefix + redactedStr;
            } else {
              return parseInt(redactedStr, 10);
            }
          }

          redactString(original) {
            const parts = original.split(/(\W+)/);
            return parts
              .map((part) => {
                if (this.ignoredWordsSet.has(part.toLowerCase())) {
                  return part;
                }
                if (!/^\w+$/.test(part)) return part;

                const isAlphabetic = /^[a-zA-Z]+$/.test(part);
                if (isAlphabetic && this.wordMap[part.length]) {
                  const newWord =
                    this.wordMap[part.length][
                      Math.floor(
                        Math.random() * this.wordMap[part.length].length
                      )
                    ];
                  return this.preserveCase(part, newWord);
                } else {
                  // Fallback if not alphabetic OR no same-length dictionary word exists
                  return this.generateRandomString(part);
                }
              })
              .join("");
          }

          preserveCase(original, newWord) {
            if (original === original.toUpperCase())
              return newWord.toUpperCase();
            if (
              original.length > 0 &&
              original[0] === original[0].toUpperCase()
            ) {
              const isTitleCase =
                original.slice(1) === original.slice(1).toLowerCase();
              if (isTitleCase)
                return (
                  newWord.charAt(0).toUpperCase() +
                  newWord.slice(1).toLowerCase()
                );
              return newWord.toUpperCase();
            }
            return newWord.toLowerCase();
          }

          generateRandomString(original) {
            const upper = "ABCDEFGHIJKLMNOPQRSTUVWXYZ",
              lower = "abcdefghijklmnopqrstuvwxyz",
              digits = "0123456789";
            let redacted = "";
            for (const char of original) {
              if (upper.includes(char))
                redacted += upper[Math.floor(Math.random() * upper.length)];
              else if (lower.includes(char))
                redacted += lower[Math.floor(Math.random() * lower.length)];
              else if (digits.includes(char))
                redacted += digits[Math.floor(Math.random() * digits.length)];
              else redacted += char;
            }
            return redacted;
          }

          static commonWords = [
            "a",
            "able",
            "about",
            "above",
            "act",
            "add",
            "afraid",
            "after",
            "again",
            "against",
            "age",
            "ago",
            "agree",
            "air",
            "all",
            "allow",
            "also",
            "always",
            "am",
            "among",
            "an",
            "and",
            "anger",
            "animal",
            "answer",
            "any",
            "appear",
            "apple",
            "are",
            "area",
            "arm",
            "arrange",
            "arrive",
            "art",
            "as",
            "ask",
            "at",
            "atom",
            "baby",
            "back",
            "bad",
            "ball",
            "band",
            "bank",
            "bar",
            "base",
            "basic",
            "bat",
            "be",
            "bear",
            "beat",
            "beauty",
            "bed",
            "been",
            "before",
            "began",
            "begin",
            "behind",
            "believe",
            "bell",
            "best",
            "better",
            "between",
            "big",
            "bird",
            "bit",
            "black",
            "block",
            "blood",
            "blow",
            "blue",
            "board",
            "boat",
            "body",
            "bone",
            "book",
            "born",
            "both",
            "bottom",
            "bought",
            "box",
            "boy",
            "branch",
            "bread",
            "break",
            "bright",
            "bring",
            "broad",
            "broke",
            "brother",
            "brought",
            "brown",
            "build",
            "burn",
            "bus",
            "busy",
            "but",
            "buy",
            "by",
            "call",
            "came",
            "camp",
            "can",
            "capital",
            "captain",
            "car",
            "card",
            "care",
            "carry",
            "case",
            "cat",
            "catch",
            "caught",
            "cause",
            "cell",
            "cent",
            "center",
            "century",
            "certain",
            "chair",
            "chance",
            "change",
            "character",
            "charge",
            "chart",
            "check",
            "chick",
            "chief",
            "child",
            "children",
            "choose",
            "chord",
            "circle",
            "city",
            "claim",
            "class",
            "clean",
            "clear",
            "climb",
            "clock",
            "close",
            "cloth",
            "cloud",
            "coast",
            "coat",
            "cold",
            "collect",
            "colony",
            "color",
            "column",
            "come",
            "common",
            "company",
            "compare",
            "complete",
            "condition",
            "connect",
            "consider",
            "consonant",
            "contain",
            "continent",
            "continue",
            "control",
            "cook",
            "cool",
            "copy",
            "corn",
            "corner",
            "correct",
            "cost",
            "cotton",
            "could",
            "count",
            "country",
            "course",
            "cover",
            "cow",
            "crease",
            "create",
            "crop",
            "cross",
            "crowd",
            "cry",
            "current",
            "cut",
            "dad",
            "dance",
            "danger",
            "dark",
            "day",
            "dead",
            "deal",
            "dear",
            "death",
            "decide",
            "decimal",
            "deep",
            "degree",
            "depend",
            "describe",
            "desert",
            "design",
            "determine",
            "develop",
            "dictionary",
            "did",
            "die",
            "differ",
            "difficult",
            "direct",
            "discover",
            "discuss",
            "distant",
            "divide",
            "division",
            "do",
            "doctor",
            "does",
            "dog",
            "dollar",
            "done",
            "door",
            "double",
            "down",
            "draw",
            "dream",
            "dress",
            "drink",
            "drive",
            "drop",
            "drove",
            "dry",
            "duck",
            "during",
            "each",
            "ear",
            "early",
            "earth",
            "ease",
            "east",
            "eat",
            "edge",
            "effect",
            "egg",
            "eight",
            "either",
            "electric",
            "element",
            "else",
            "end",
            "enemy",
            "energy",
            "engine",
            "enough",
            "enter",
            "equal",
            "equate",
            "especially",
            "even",
            "evening",
            "event",
            "ever",
            "every",
            "exact",
            "example",
            "except",
            "excite",
            "exercise",
            "expect",
            "experience",
            "experiment",
            "eye",
            "face",
            "fact",
            "fair",
            "fall",
            "family",
            "famous",
            "far",
            "farm",
            "fast",
            "father",
            "favor",
            "fear",
            "feed",
            "feel",
            "feet",
            "fell",
            "felt",
            "few",
            "field",
            "fig",
            "fight",
            "figure",
            "fill",
            "final",
            "find",
            "fine",
            "finger",
            "finish",
            "fire",
            "first",
            "fish",
            "fit",
            "five",
            "flat",
            "floor",
            "flow",
            "flower",
            "fly",
            "follow",
            "food",
            "foot",
            "for",
            "force",
            "foreign",
            "forest",
            "form",
            "forward",
            "found",
            "four",
            "fraction",
            "free",
            "fresh",
            "friend",
            "from",
            "front",
            "fruit",
            "fry",
            "full",
            "fun",
            "game",
            "garden",
            "gas",
            "gather",
            "gave",
            "general",
            "gentle",
            "get",
            "girl",
            "give",
            "glad",
            "glass",
            "go",
            "gold",
            "gone",
            "good",
            "got",
            "govern",
            "grand",
            "grass",
            "gray",
            "great",
            "green",
            "grew",
            "ground",
            "group",
            "grow",
            "guess",
            "guide",
            "gun",
            "had",
            "hair",
            "half",
            "hand",
            "happen",
            "happy",
            "hard",
            "has",
            "hat",
            "have",
            "he",
            "head",
            "hear",
            "heard",
            "heart",
            "heat",
            "heavy",
            "held",
            "help",
            "her",
            "here",
            "high",
            "hill",
            "him",
            "his",
            "history",
            "hit",
            "hold",
            "hole",
            "home",
            "hope",
            "horse",
            "hot",
            "hour",
            "house",
            "how",
            "huge",
            "human",
            "hundred",
            "hunt",
            "hurry",
            "i",
            "ice",
            "idea",
            "if",
            "imagine",
            "in",
            "inch",
            "include",
            "indicate",
            "industry",
            "insect",
            "instant",
            "instrument",
            "interest",
            "invent",
            "iron",
            "is",
            "island",
            "it",
            "job",
            "join",
            "joy",
            "jump",
            "just",
            "keep",
            "kept",
            "key",
            "kill",
            "kind",
            "king",
            "knew",
            "know",
            "knowledge",
            "la",
            "lack",
            "lady",
            "laid",
            "lake",
            "land",
            "language",
            "large",
            "last",
            "late",
            "laugh",
            "law",
            "lay",
            "lead",
            "learn",
            "least",
            "leave",
            "led",
            "left",
            "leg",
            "length",
            "less",
            "let",
            "letter",
            "level",
            "lie",
            "life",
            "lift",
            "light",
            "like",
            "line",
            "liquid",
            "list",
            "listen",
            "little",
            "live",
            "locate",
            "log",
            "lone",
            "long",
            "look",
            "lost",
            "lot",
            "loud",
            "love",
            "low",
            "machine",
            "made",
            "magnet",
            "main",
            "major",
            "make",
            "man",
            "many",
            "map",
            "mark",
            "market",
            "mass",
            "master",
            "match",
            "material",
            "matter",
            "may",
            "me",
            "mean",
            "meant",
            "measure",
            "meat",
            "meet",
            "melody",
            "men",
            "metal",
            "method",
            "middle",
            "might",
            "mile",
            "milk",
            "million",
            "mind",
            "mine",
            "minute",
            "miss",
            "mix",
            "modern",
            "molecule",
            "moment",
            "money",
            "month",
            "moon",
            "more",
            "morning",
            "most",
            "mother",
            "motion",
            "mount",
            "mountain",
            "mouse",
            "mouth",
            "move",
            "much",
            "multiply",
            "music",
            "must",
            "my",
            "name",
            "nation",
            "natural",
            "nature",
            "near",
            "necessary",
            "neck",
            "need",
            "neighbor",
            "never",
            "new",
            "next",
            "night",
            "nine",
            "no",
            "noise",
            "noon",
            "nor",
            "north",
            "nose",
            "not",
            "note",
            "nothing",
            "notice",
            "noun",
            "now",
            "number",
            "numeral",
            "object",
            "observe",
            "occur",
            "ocean",
            "of",
            "off",
            "offer",
            "office",
            "often",
            "oh",
            "oil",
            "old",
            "on",
            "once",
            "one",
            "only",
            "open",
            "operate",
            "opposite",
            "or",
            "order",
            "organ",
            "original",
            "other",
            "our",
            "out",
            "over",
            "own",
            "oxygen",
            "page",
            "paint",
            "pair",
            "paper",
            "paragraph",
            "parent",
            "part",
            "particular",
            "party",
            "pass",
            "past",
            "path",
            "pattern",
            "pay",
            "people",
            "perhaps",
            "period",
            "person",
            "phrase",
            "pick",
            "picture",
            "piece",
            "pitch",
            "place",
            "plain",
            "plan",
            "plane",
            "planet",
            "plant",
            "play",
            "please",
            "plural",
            "poem",
            "point",
            "pole",
            "populate",
            "port",
            "pose",
            "position",
            "possible",
            "post",
            "pound",
            "power",
            "practice",
            "prepare",
            "present",
            "press",
            "pretty",
            "print",
            "probable",
            "problem",
            "process",
            "produce",
            "product",
            "program",
            "proof",
            "proper",
            "property",
            "protect",
            "provide",
            "pull",
            "push",
            "put",
            "quart",
            "question",
            "quick",
            "quiet",
            "quite",
            "race",
            "radio",
            "rail",
            "rain",
            "raise",
            "ran",
            "range",
            "rather",
            "reach",
            "read",
            "ready",
            "real",
            "reason",
            "receive",
            "record",
            "red",
            "region",
            "remember",
            "repeat",
            "reply",
            "represent",
            "require",
            "rest",
            "result",
            "rich",
            "ride",
            "right",
            "ring",
            "rise",
            "river",
            "road",
            "rock",
            "roll",
            "room",
            "root",
            "rope",
            "rose",
            "round",
            "row",
            "rub",
            "rule",
            "run",
            "safe",
            "said",
            "sail",
            "salt",
            "same",
            "sand",
            "sat",
            "save",
            "saw",
            "say",
            "scale",
            "school",
            "science",
            "score",
            "sea",
            "search",
            "season",
            "seat",
            "second",
            "secret",
            "section",
            "see",
            "seed",
            "seem",
            "segment",
            "select",
            "self",
            "sell",
            "send",
            "sense",
            "sent",
            "sentence",
            "separate",
            "serve",
            "set",
            "settle",
            "seven",
            "several",
            "shall",
            "shape",
            "share",
            "sharp",
            "she",
            "sheet",
            "shell",
            "shine",
            "ship",
            "shoe",
            "shoot",
            "shop",
            "shore",
            "short",
            "should",
            "shoulder",
            "shout",
            "show",
            "side",
            "sight",
            "sign",
            "signal",
            "silent",
            "silver",
            "similar",
            "simple",
            "since",
            "sing",
            "single",
            "sister",
            "sit",
            "six",
            "size",
            "skill",
            "skin",
            "sky",
            "slave",
            "sleep",
            "slip",
            "slow",
            "small",
            "smell",
            "smile",
            "snow",
            "so",
            "soft",
            "soil",
            "soldier",
            "solution",
            "solve",
            "some",
            "son",
            "song",
            "soon",
            "sound",
            "south",
            "space",
            "speak",
            "special",
            "speech",
            "speed",
            "spell",
            "spend",
            "spoke",
            "spot",
            "spread",
            "spring",
            "square",
            "stand",
            "star",
            "start",
            "state",
            "station",
            "stay",
            "stead",
            "steam",
            "steel",
            "step",
            "stick",
            "still",
            "stone",
            "stood",
            "stop",
            "store",
            "story",
            "straight",
            "stream",
            "street",
            "stretch",
            "string",
            "strong",
            "student",
            "study",
            "subject",
            "substance",
            "subtract",
            "such",
            "sudden",
            "suffix",
            "sugar",
            "suggest",
            "suit",
            "summer",
            "sun",
            "supply",
            "support",
            "sure",
            "surface",
            "surprise",
            "swim",
            "syllable",
            "symbol",
            "system",
            "table",
            "tail",
            "take",
            "talk",
            "tall",
            "teach",
            "team",
            "tell",
            "temperature",
            "ten",
            "term",
            "test",
            "than",
            "thank",
            "that",
            "the",
            "their",
            "them",
            "then",
            "there",
            "these",
            "they",
            "thick",
            "thin",
            "thing",
            "think",
            "third",
            "this",
            "those",
            "though",
            "thought",
            "thousand",
            "three",
            "threw",
            "through",
            "throw",
            "thus",
            "tie",
            "tight",
            "time",
            "tiny",
            "tip",
            "tire",
            "to",
            "together",
            "told",
            "tone",
            "too",
            "took",
            "tool",
            "top",
            "total",
            "touch",
            "toward",
            "town",
            "track",
            "trade",
            "train",
            "transport",
            "travel",
            "treat",
            "tree",
            "triangle",
            "trip",
            "trouble",
            "truck",
            "true",
            "try",
            "tube",
            "turn",
            "twenty",
            "two",
            "type",
            "under",
            "unit",
            "until",
            "up",
            "us",
            "use",
            "usual",
            "valley",
            "valuable",
            "value",
            "vapor",
            "vary",
            "verb",
            "very",
            "view",
            "village",
            "visit",
            "voice",
            "vowel",
            "wait",
            "walk",
            "wall",
            "want",
            "war",
            "warm",
            "was",
            "wash",
            "watch",
            "water",
            "wave",
            "way",
            "we",
            "wear",
            "weather",
            "week",
            "weigh",
            "well",
            "went",
            "were",
            "west",
            "what",
            "wheel",
            "when",
            "where",
            "whether",
            "which",
            "while",
            "white",
            "who",
            "whole",
            "whose",
            "why",
            "wide",
            "wife",
            "wild",
            "will",
            "win",
            "wind",
            "window",
            "wing",
            "winter",
            "wire",
            "wish",
            "with",
            "woman",
            "women",
            "wonder",
            "wood",
            "word",
            "work",
            "world",
            "would",
            "write",
            "written",
            "wrong",
            "wrote",
            "yard",
            "year",
            "yellow",
            "yes",
            "yet",
            "you",
            "young",
            "your",
            "acknowledgement",
            "administrative",
            "advertisement",
            "approximately",
            "communication",
            "comprehension",
            "concentration",
            "congratulations",
            "conscientious",
            "consciousness",
            "consideration",
            "constitutional",
            "contemporary",
            "contradiction",
            "contribution",
            "correspondence",
            "demonstration",
            "disappointment",
            "discrimination",
            "documentation",
            "encouragement",
            "environmental",
            "establishment",
            "extraordinary",
            "generalization",
            "identification",
            "implementation",
            "infrastructure",
            "instrumentation",
            "intellectual",
            "interpretation",
            "investigation",
            "justification",
            "manufacturing",
            "multiplication",
            "neighborhood",
            "organization",
            "participation",
            "pharmaceutical",
            "philosophical",
            "photosynthesis",
            "possibility",
            "practitioner",
            "pronunciation",
            "psychological",
            "qualification",
            "recommendation",
            "representation",
            "responsibility",
            "revolutionary",
            "satisfaction",
            "simplification",
            "simultaneously",
            "specialization",
            "standardization",
            "transformation",
            "transportation",
            "understanding",
            "vulnerability",
            "characterization",
            "conceptualize",
            "industrialize",
            "international",
            "misunderstanding",
            "professionalisms",
            "institutionalize",
            "decontextualize",
            "incomprehensible",
            "counterrevolution",
            "electrocardiogram",
            "characteristically",
            "internationalism",
            "professionalized",
            "unintelligibility",
            "counterintelligence",
            "institutionalizing",
            "professionalization",
            "telecommunication",
            "weatherforecasting",
            "counterrevolutionist",
            "deindustrialization",
            "misunderstandingly",
            "professionalizing",
            "interconnectedness",
            "counterdemonstration",
            "institutionalisation",
            "professionalisations",
            "telecommunicational",
            "uncharacteristically",
          ];
        }

        // --- Format-Specific Handlers ---
        let redactor;
        let toastTimeout;

        function redactJsonStructure(value, currentRedactor, key = null) {
          if (value === null) return null;
          // CSRF check for any value type
          if (currentRedactor.settings.redactCsrf && typeof key === "string") {
            const lowerKey = key.toLowerCase();
            if (lowerKey.includes("csrf") || lowerKey.includes("xsrf")) {
              return currentRedactor.redactString(String(value));
            }
          }
          if (typeof value === "boolean") return Math.random() < 0.5;
          if (typeof value === "number")
            return currentRedactor.redactNumber(String(value));
          if (typeof value === "string") {
            return currentRedactor.redactPrimitive(value);
          }
          if (Array.isArray(value))
            return value.map((item) =>
              redactJsonStructure(item, currentRedactor)
            ); // key is null
          if (typeof value === "object")
            return Object.entries(value).reduce(
              (acc, [k, v]) => ({
                ...acc,
                [k]: redactJsonStructure(v, currentRedactor, k),
              }),
              {}
            );
          return value;
        }

        function handleJson(text) {
          const data = JSON.parse(text);
          const sorted = sortObjectKeys(data);
          const formattedInput = JSON.stringify(sorted, null, 2);
          const redacted = redactJsonStructure(sorted, redactor);
          const redactedString = JSON.stringify(redacted, null, 2);
          const finalString = redactedString.replace(
            new RegExp(`"${redactor.floatPlaceholderPrefix}([-.0-9]+)"`, "g"),
            (m, n) => n
          );
          updateActiveTabData({
            input: formattedInput,
            output: finalString,
            format: "JSON",
          });
          function sortObjectKeys(obj) {
            if (typeof obj !== "object" || obj === null) return obj;
            if (Array.isArray(obj)) return obj.map(sortObjectKeys);
            return Object.keys(obj)
              .sort()
              .reduce(
                (res, k) => ({ ...res, [k]: sortObjectKeys(obj[k]) }),
                {}
              );
          }
        }

        function handleYaml(text) {
          const data = jsyaml.load(text);
          const redacted = redactJsonStructure(data, redactor);
          const redactedYaml = jsyaml.dump(redacted, { noArrayIndent: true });
          updateActiveTabData({
            input: text,
            output: redactedYaml,
            format: "YAML",
          });
        }

        function handleXml(text) {
          const parser = new DOMParser();
          const xmlDoc = parser.parseFromString(text, "application/xml");
          if (xmlDoc.getElementsByTagName("parsererror").length)
            throw new Error("XML parsing error.");
          const formattedInput = formatXml(xmlDoc);
          traverseAndRedact(xmlDoc.documentElement);
          const formattedOutput = formatXml(xmlDoc);
          const finalOutput = formattedOutput.replace(
            new RegExp(redactor.floatPlaceholderPrefix, "g"),
            ""
          );
          updateActiveTabData({
            input: formattedInput,
            output: finalOutput,
            format: "XML",
          });
          function traverseAndRedact(node) {
            if (node.nodeType === 3 && node.nodeValue.trim()) {
              node.nodeValue = redactor.redactPrimitive(node.nodeValue);
            }
            if (node.attributes) {
              Array.from(node.attributes).forEach(
                (attr) => (attr.value = redactor.redactPrimitive(attr.value))
              );
            }
            node.childNodes.forEach(traverseAndRedact);
          }
          function formatXml(xmlNode) {
            const serializer = new XMLSerializer();
            const xmlString = serializer.serializeToString(xmlNode);
            let contentString = xmlString;
            let declaration = "";
            const declMatch = xmlString.match(/(<\?xml[^>]*\?>\s*)/);
            if (declMatch) {
              declaration = declMatch[0];
              contentString = xmlString.substring(declaration.length);
            }
            let formatted = "",
              indent = "";
            const tab = "  ";
            const parts = contentString.split(/>\s*</);
            if (parts.length === 1 && !declaration) return xmlString;
            parts.forEach((node, index) => {
              let isClosing = node.startsWith("/");
              if (isClosing) indent = indent.substring(tab.length);
              let padding = indent;
              if (index > 0) padding = "\n" + indent;
              let reconstructedNode =
                index === 0
                  ? node + ">"
                  : index === parts.length - 1
                  ? "<" + node
                  : "<" + node + ">";
              if (reconstructedNode.trim())
                formatted += padding + reconstructedNode;
              if (
                !isClosing &&
                !node.endsWith("/") &&
                !reconstructedNode.includes("</")
              )
                indent += tab;
            });
            return declaration + formatted;
          }
        }

        function handleFormUrlEncoded(text) {
          const trimmedText = text.trim();
          if (
            !text.includes("=") ||
            trimmedText.startsWith("{") ||
            trimmedText.startsWith("<") ||
            trimmedText.startsWith("HTTP/")
          ) {
            throw new Error("Not an application/x-www-form-urlencoded string.");
          }
          const params = new URLSearchParams(text);
          if (Array.from(params.keys()).length === 0) {
            throw new Error("No valid parameters found.");
          }
          const redactedParams = new URLSearchParams();
          for (const [key, value] of params.entries()) {
            let redactedValue;
            const redactedKey = settings.redaction.redactParamNames
              ? redactor.redactString(key)
              : key;
            if (
              redactor.settings.redactCsrf &&
              key.toLowerCase().includes("csrf")
            ) {
              redactedValue = redactor.redactString(value);
            } else {
              const primitive = redactor.redactPrimitive(value);
              redactedValue =
                typeof primitive === "string" &&
                primitive.startsWith(redactor.floatPlaceholderPrefix)
                  ? primitive.substring(redactor.floatPlaceholderPrefix.length)
                  : String(primitive);
            }
            redactedParams.append(redactedKey, redactedValue);
          }
          const formatParams = (p) => p.toString();
          updateActiveTabData({
            input: formatParams(params),
            output: formatParams(redactedParams),
            format: "Form URL-Encoded",
          });
        }

        function handleHttp(text) {
          const lines = text.split(/\r?\n/);
          const firstLine = lines[0].trim();
          const reqRegex =
            /^(GET|POST|PUT|DELETE|PATCH|HEAD|OPTIONS|TRACE|CONNECT)\s+(.+)\s+HTTP\/[12](\.\d)?$/;
          const resRegex = /^HTTP\/[12](\.\d)?\s+(\d{3})\s+(.*)$/;
          const reqMatch = firstLine.match(reqRegex);
          const resMatch = firstLine.match(resRegex);
          if (!reqMatch && !resMatch)
            throw new Error("Not an HTTP request or response.");

          let headerEndIndex = lines.findIndex((line) => line.trim() === "");
          if (headerEndIndex === -1) headerEndIndex = lines.length;
          const headerLinesOnly = lines.slice(1, headerEndIndex);
          const headerBlock = lines.slice(0, headerEndIndex).join("\n");
          const body = lines.slice(headerEndIndex + 1).join("\n");
          let formattedInput = text;

          let contentType = "";
          const contentTypeHeader = headerLinesOnly.find((h) =>
            h.toLowerCase().startsWith("content-type:")
          );
          if (contentTypeHeader) {
            contentType = contentTypeHeader.split(":")[1].trim().split(";")[0];
          }

          // Check if the body is JSON and prettify it for the input display
          if (
            contentType.includes("json") ||
            (!contentType && body.trim().startsWith("{"))
          ) {
            try {
              const bodyJson = JSON.parse(body);
              const sorted = sortObjectKeys(bodyJson);
              const prettifiedBody = JSON.stringify(sorted, null, 2);
              if (body !== prettifiedBody) {
                formattedInput = headerBlock + "\n\n" + prettifiedBody;
              }
            } catch (e) {
              // Body is not valid JSON, do nothing to the input
            }
          }

          let redactedStartLine;
          if (reqMatch) {
            let pathAndQuery = reqMatch[2];
            const [path, queryString] = pathAndQuery.split("?");
            let redactedQuery = "";

            if (queryString) {
              if (settings.redaction.redactQueryString) {
                const params = new URLSearchParams(queryString);
                const redactedParams = new URLSearchParams();
                for (const [key, value] of params) {
                  const redactedKey = settings.redaction.redactParamNames
                    ? redactor.redactString(key)
                    : key;
                  const redactedValue = redactor.redactPrimitive(value);
                  redactedParams.append(
                    redactedKey,
                    typeof redactedValue === "string"
                      ? redactedValue.replace(
                          redactor.floatPlaceholderPrefix,
                          ""
                        )
                      : redactedValue
                  );
                }
                redactedQuery = "?" + redactedParams.toString();
              } else {
                redactedQuery = "?" + queryString;
              }
            }

            const redactedPath = settings.redaction.redactUrlPath
              ? redactor.redactString(path)
              : path;
            pathAndQuery = redactedPath + redactedQuery;

            redactedStartLine = `${reqMatch[1]} ${pathAndQuery} HTTP/1.1`;
          } else {
            redactedStartLine = `HTTP/1.1 ${
              resMatch[1]
            } ${redactor.redactString(resMatch[2])}`;
          }

          const redactedHeaders = headerLinesOnly
            .map((headerLine) => {
              const parts = headerLine.split(/:\s*(.*)/s);
              if (parts.length < 2) return headerLine;
              const key = parts[0];
              const value = parts[1] || "";
              const lowerKey = key.toLowerCase();

              if (
                settings.redaction.redactCookies &&
                (lowerKey === "cookie" || lowerKey === "set-cookie")
              ) {
                const redactedCookieValue = value
                  .split(";")
                  .map((cookiePair) => {
                    const trimmedPair = cookiePair.trim();
                    const separatorIndex = trimmedPair.indexOf("=");
                    if (separatorIndex === -1) return trimmedPair; // Attribute without value like "HttpOnly"

                    const cookieName = trimmedPair.substring(0, separatorIndex);
                    const cookieValue = trimmedPair.substring(
                      separatorIndex + 1
                    );
                    return `${cookieName}=${redactor.redactString(
                      cookieValue
                    )}`;
                  })
                  .join("; ");
                return `${key}: ${redactedCookieValue}`;
              }

              if (
                settings.redaction.redactCookies &&
                (lowerKey === "authorization" ||
                  lowerKey === "proxy-authorization")
              ) {
                return `${key}: ${redactor.redactString(value)}`;
              }
              const csrfHeaderNames = [
                "x-csrf-token",
                "x-xsrf-token",
                "csrf-token",
              ];
              if (
                settings.redaction.redactCsrf &&
                csrfHeaderNames.includes(lowerKey)
              ) {
                return `${key}: ${redactor.redactString(value)}`;
              }
              const safeHeaders = [
                "host",
                "content-type",
                "content-length",
                "connection",
                "accept",
                "user-agent",
                "date",
                "server",
                "accept-encoding",
                "accept-language",
              ];
              if (safeHeaders.includes(lowerKey)) return headerLine;

              return `${key}: ${redactor.redactString(value)}`;
            })
            .join("\n");

          const redactedBody = redactBodyContent(body, redactor, contentType);
          const finalRedacted = `${redactedStartLine}\n${redactedHeaders}${
            body ? "\n\n" + redactedBody : ""
          }`;

          updateActiveTabData({
            input: formattedInput,
            output: finalRedacted,
            format: reqMatch ? "HTTP Request" : "HTTP Response",
          });

          function sortObjectKeys(obj) {
            if (typeof obj !== "object" || obj === null) return obj;
            if (Array.isArray(obj)) return obj.map(sortObjectKeys);
            return Object.keys(obj)
              .sort()
              .reduce(
                (res, k) => ({ ...res, [k]: sortObjectKeys(obj[k]) }),
                {}
              );
          }
        }

        function redactBodyContent(
          bodyText,
          currentRedactor,
          contentType = ""
        ) {
          if (!bodyText) return "";

          const runJsonRedaction = () => {
            const redacted = redactJsonStructure(
              JSON.parse(bodyText),
              currentRedactor
            );
            const redactedString = JSON.stringify(redacted, null, 2);
            return redactedString.replace(
              new RegExp(
                `"${currentRedactor.floatPlaceholderPrefix}([-.0-9]+)"`,
                "g"
              ),
              (m, n) => n
            );
          };
          const runYamlRedaction = () => {
            const redacted = redactJsonStructure(
              jsyaml.load(bodyText),
              currentRedactor
            );
            return jsyaml.dump(redacted, { noArrayIndent: true });
          };
          const runXmlRedaction = () => {
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(bodyText, "application/xml");
            if (xmlDoc.getElementsByTagName("parsererror").length > 0)
              throw new Error();
            function traverse(node) {
              if (node.nodeType === 3 && node.nodeValue.trim()) {
                node.nodeValue = currentRedactor.redactPrimitive(
                  node.nodeValue
                );
              }
              if (node.attributes) {
                Array.from(node.attributes).forEach(
                  (attr) =>
                    (attr.value = currentRedactor.redactPrimitive(attr.value))
                );
              }
              node.childNodes.forEach(traverse);
            }
            traverse(xmlDoc.documentElement);
            const serializedXml = new XMLSerializer().serializeToString(xmlDoc);
            return serializedXml.replace(
              new RegExp(currentRedactor.floatPlaceholderPrefix, "g"),
              ""
            );
          };
          const runFormUrlEncodedRedaction = () => {
            if (!bodyText.includes("=")) throw new Error();
            const params = new URLSearchParams(bodyText);
            if (Array.from(params.keys()).length === 0) throw new Error();
            const redactedParams = new URLSearchParams();
            for (const [key, value] of params.entries()) {
              let redactedValue;
              const redactedKey = currentRedactor.settings.redactParamNames
                ? currentRedactor.redactString(key)
                : key;
              if (
                currentRedactor.settings.redactCsrf &&
                key.toLowerCase().includes("csrf")
              ) {
                redactedValue = currentRedactor.redactString(value);
              } else {
                const p = currentRedactor.redactPrimitive(value);
                redactedValue =
                  typeof p === "string" &&
                  p.startsWith(currentRedactor.floatPlaceholderPrefix)
                    ? p.substring(currentRedactor.floatPlaceholderPrefix.length)
                    : String(p);
              }
              redactedParams.append(redactedKey, redactedValue);
            }
            return redactedParams.toString();
          };
          const runPlainTextRedaction = () => {
            return bodyText
              .split("\n")
              .map((line) => currentRedactor.redactString(line))
              .join("\n");
          };

          const mainContentType = contentType.split(";")[0].trim();

          const contentMap = {
            "application/json": runJsonRedaction,
            "application/xml": runXmlRedaction,
            "text/xml": runXmlRedaction,
            "application/x-www-form-urlencoded": runFormUrlEncodedRedaction,
            "application/yaml": runYamlRedaction,
            "text/yaml": runYamlRedaction,
          };

          if (contentMap[mainContentType]) {
            try {
              return contentMap[mainContentType]();
            } catch (e) {
              // Fallback if parsing fails despite content-type header
              return runPlainTextRedaction();
            }
          }

          // Fallback detection if content-type is missing or not recognized
          try {
            return runJsonRedaction();
          } catch (e) {}
          try {
            return runYamlRedaction();
          } catch (e) {}
          try {
            return runXmlRedaction();
          } catch (e) {}
          try {
            return runFormUrlEncodedRedaction();
          } catch (e) {}

          return runPlainTextRedaction();
        }

        function handlePlainText(text) {
          const redactedText = text
            .split("\n")
            .map((line) => redactor.redactString(line))
            .join("\n");
          updateActiveTabData({ output: redactedText, format: "Plain Text" });
        }

        // --- Event Dispatcher ---
        function showError(message) {
          errorMessageEl.textContent = message;
          errorToast.classList.remove("hidden");
          clearTimeout(toastTimeout);
          toastTimeout = setTimeout(
            () => errorToast.classList.add("hidden"),
            3000
          );
        }

        function handleRedaction() {
          redactor = new RedactionEngine(settings.redaction);
          const activeTab = tabsState.find((t) => t.id === activeTabId);
          if (!activeTab) return;

          const text = inputEditor.getValue();
          activeTab.input = text;
          const trimmedText = text.trim();

          if (!trimmedText) {
            updateActiveTabData({ output: "", format: "" });
            renderContent();
            return;
          }

          const format = detectFormat(text);
          activeTab.format = format;

          try {
            switch (format) {
              case "HTTP Request":
              case "HTTP Response":
                handleHttp(text);
                break;
              case "JSON":
                handleJson(trimmedText);
                break;
              case "XML":
                handleXml(trimmedText);
                break;
              case "YAML":
                handleYaml(trimmedText);
                break;
              case "Form URL-Encoded":
                handleFormUrlEncoded(trimmedText);
                break;
              default:
                handlePlainText(text);
            }
          } catch (e) {
            console.error("Redaction Error:", e);
            showError(`Failed to process as ${format}.`);
            handlePlainText(text); // Fallback to plain text on error
          }

          render();
        }

        function updateActiveTabData(data) {
          const activeTab = tabsState.find((t) => t.id === activeTabId);
          if (activeTab) {
            Object.assign(activeTab, data);
            if (activeTab.originalName && data.format) {
              const tabNumber = activeTab.originalName.split(" ")[1] || "";
              let baseName = data.format.startsWith("HTTP")
                ? data.format
                : data.format.split(" ")[0];
              activeTab.name = `${baseName} ${tabNumber}`.trim();
            }
          }
        }

        function detectFormat(text) {
          const trimmedText = text.trim();
          if (!trimmedText) return "";

          try {
            const firstLine = text.split(/\r?\n/)[0].trim();
            const reqRegex =
              /^(GET|POST|PUT|DELETE|PATCH|HEAD|OPTIONS|TRACE|CONNECT)\s+(.+)\s+HTTP\/[12](\.\d)?$/;
            const resRegex = /^HTTP\/[12](\.\d)?\s+(\d{3})\s+(.*)$/;
            if (reqRegex.test(firstLine)) return "HTTP Request";
            if (resRegex.test(firstLine)) return "HTTP Response";
          } catch (e) {}

          try {
            JSON.parse(trimmedText);
            return "JSON";
          } catch (e) {}

          try {
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(
              trimmedText,
              "application/xml"
            );
            if (xmlDoc.getElementsByTagName("parsererror").length > 0)
              throw new Error();
            return "XML";
          } catch (e) {}

          try {
            // More specific YAML check: must contain a colon or a dash at the start of a line
            if (!/:\s|\n\s*-/.test(text)) throw new Error();
            const doc = jsyaml.load(text);
            if (
              typeof doc === "object" &&
              doc !== null &&
              Object.keys(doc).length > 0
            )
              return "YAML";
            if (Array.isArray(doc) && doc.length > 0) return "YAML";
          } catch (e) {}

          try {
            if (
              !trimmedText.includes("=") ||
              trimmedText.startsWith("{") ||
              trimmedText.startsWith("<") ||
              trimmedText.startsWith("HTTP/")
            ) {
              throw new Error();
            }
            const params = new URLSearchParams(trimmedText);
            if (Array.from(params.keys()).length === 0) throw new Error();
            return "Form URL-Encoded";
          } catch (e) {}

          return "Plain Text";
        }

        // --- Initial Setup and Event Listeners ---
        function updateTheme(isDark) {
          document.documentElement.classList.toggle("dark", isDark);
          const newTheme = isDark ? "material-darker" : "eclipse";
          inputEditor.setOption("theme", newTheme);
          outputEditor.setOption("theme", newTheme);
        }

        settingsButton.addEventListener("click", () =>
          settingsModal.classList.remove("hidden")
        );
        closeSettingsButton.addEventListener("click", () =>
          settingsModal.classList.add("hidden")
        );
        settingsModal.addEventListener("click", (e) => {
          if (e.target === settingsModal) settingsModal.classList.add("hidden");
        });

        // Settings Listeners
        settingRedactUrlPath.addEventListener("change", (e) => {
          settings.redaction.redactUrlPath = e.target.checked;
          saveSettings();
        });
        settingRedactQueryString.addEventListener("change", (e) => {
          settings.redaction.redactQueryString = e.target.checked;
          saveSettings();
        });
        settingRedactParamNames.addEventListener("change", (e) => {
          settings.redaction.redactParamNames = e.target.checked;
          saveSettings();
        });
        settingRedactCookies.addEventListener("change", (e) => {
          settings.redaction.redactCookies = e.target.checked;
          saveSettings();
        });
        settingRedactCsrf.addEventListener("change", (e) => {
          settings.redaction.redactCsrf = e.target.checked;
          saveSettings();
        });
        settingIgnoredWords.addEventListener("input", (e) => {
          settings.redaction.ignoredWords = e.target.value
            .split(",")
            .map((word) => word.trim())
            .filter((word) => word.length > 0);
          saveSettings();
        });
        settingDarkTheme.addEventListener("change", (e) => {
          settings.ui.useDarkTheme = e.target.checked;
          updateTheme(settings.ui.useDarkTheme);
          saveSettings();
        });
        settingSyntaxHighlight.addEventListener("change", (e) => {
          settings.ui.syntaxHighlight = e.target.checked;
          saveSettings();
          renderContent(); // Re-render to apply syntax highlighting change immediately
        });

        tabsContainer.addEventListener("click", (e) => {
          if (
            e.target.id === "add-tab-button" ||
            e.target.closest("#add-tab-button")
          ) {
            const newTab = createNewTab();
            switchTab(newTab.id);
            return;
          }
          const tabEl = e.target.closest("[data-tab-id]");
          if (!tabEl) return;
          const tabId = Number(tabEl.dataset.tabId);
          if (e.target.tagName === "BUTTON") {
            e.stopPropagation();
            closeTab(tabId);
          } else {
            switchTab(tabId);
          }
        });

        tabsContainer.addEventListener("dblclick", (e) => {
          const titleEl = e.target.closest("span");
          if (!titleEl) return;
          const tabEl = titleEl.closest("[data-tab-id]");
          const tabId = Number(tabEl.dataset.tabId);
          const tab = tabsState.find((t) => t.id === tabId);
          const input = document.createElement("input");
          input.type = "text";
          input.value = tab.name;
          input.className =
            "bg-gray-300 dark:bg-gray-600 text-gray-900 dark:text-white outline-none rounded px-2 w-full";
          titleEl.replaceWith(input);
          input.focus();
          input.select();
          const finishEditing = () => {
            const newName = input.value.trim();
            if (newName) {
              tab.name = newName;
              tab.originalName = null;
            }
            input.replaceWith(titleEl);
            renderTabs();
          };
          input.addEventListener("blur", finishEditing);
          input.addEventListener("keydown", (e) => {
            if (e.key === "Enter") input.blur();
          });
        });

        inputEditor.on("change", (instance) => {
          const text = instance.getValue();
          const activeTab = tabsState.find((t) => t.id === activeTabId);
          if (activeTab) {
            activeTab.input = text;
          }

          // Debounce syntax highlighting update
          clearTimeout(syntaxUpdateTimer);
          syntaxUpdateTimer = setTimeout(() => {
            const format = detectFormat(text);
            const activeTab = tabsState.find((t) => t.id === activeTabId);
            if (activeTab && activeTab.format !== format) {
              activeTab.format = format;
              render();
            }
          }, 500);
        });

        copyButton.addEventListener("click", (e) => {
          const textToCopy = outputEditor.getValue();
          if (!textToCopy) return;
          const tempTextArea = document.createElement("textarea");
          tempTextArea.value = textToCopy;
          document.body.appendChild(tempTextArea);
          tempTextArea.select();
          try {
            document.execCommand("copy");
            const originalIcon = copyButton.innerHTML;
            copyButton.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-green-400"><polyline points="20 6 9 17 4 12"></polyline></svg>`;
            setTimeout(() => {
              copyButton.innerHTML = originalIcon;
            }, 1500);
          } catch (err) {
            console.error("Fallback: Oops, unable to copy", err);
            showError("Could not copy to clipboard.");
          }
          document.body.removeChild(tempTextArea);
        });

        redactButton.addEventListener("click", handleRedaction);

        document.addEventListener("keydown", (e) => {
          if ((e.metaKey || e.ctrlKey) && e.key === "Enter") {
            e.preventDefault();
            redactButton.click();
          }
        });

        // --- Synchronized Scrolling ---
        let isSyncing = false;
        function syncScroll(source, target) {
          if (!isSyncing) {
            isSyncing = true;
            const sourceInfo = source.getScrollInfo();
            target.scrollTo(sourceInfo.left, sourceInfo.top);
            isSyncing = false;
          }
        }
        inputEditor.on("scroll", () => syncScroll(inputEditor, outputEditor));
        outputEditor.on("scroll", () => syncScroll(outputEditor, inputEditor));

        // --- Splitter Logic ---
        const splitter = document.getElementById("splitter"),
          leftPanel = document.getElementById("left-panel"),
          rightPanel = document.getElementById("right-panel"),
          container = document.getElementById("container");
        let isDragging = false;
        splitter.addEventListener("mousedown", () => (isDragging = true));
        document.addEventListener("mouseup", () => {
          if (isDragging) {
            isDragging = false;
            inputEditor.refresh();
            outputEditor.refresh();
          }
        });
        document.addEventListener("mousemove", (e) => {
          if (!isDragging) return;
          e.preventDefault();
          const containerRect = container.getBoundingClientRect();
          const newLeftWidth = e.clientX - containerRect.left;
          if (
            newLeftWidth > 100 &&
            newLeftWidth < container.clientWidth - 100
          ) {
            const newLeftPercent = (newLeftWidth / container.clientWidth) * 100;
            leftPanel.style.width = `${newLeftPercent}%`;
            rightPanel.style.width = `${100 - newLeftPercent}%`;
          }
        });

        // --- Tab Scrolling ---
        scrollLeftButton.addEventListener("click", () => {
          tabsContainer.scrollBy({ left: -200, behavior: "smooth" });
        });
        scrollRightButton.addEventListener("click", () => {
          tabsContainer.scrollBy({ left: 200, behavior: "smooth" });
        });
        tabsContainer.addEventListener("scroll", updateScrollButtonStates);
        new ResizeObserver(checkTabOverflow).observe(tabsContainer);
        window.addEventListener("resize", checkTabOverflow);

        // --- Initialize First Tab & Settings ---
        loadSettings();
        updateTheme(settings.ui.useDarkTheme);
        const firstTab = createNewTab();
        activeTabId = firstTab.id;
        render();
      });
    </script>
  </body>
</html>
